\documentclass[final]{fhnwreport}       %[mode] = draft or final
                                        %{class} = fhnwreport, article, 
                                        %          report, book, beamer, standalone
%\usepackage{hyperref}
%\usepackage{graphicx}
%\usepackage{longtable} % To display tables on several pages
%\usepackage{geometry}
%\usepackage{listings}
\usepackage{lipsum}
\usepackage{silence}
\usepackage{subfig}
\usepackage{minted}
\WarningFilter{hyperref}{Draft mode on}
\WarningFilter{latex}{Marginpar}

% Load the package
\usepackage[toc]{glossaries}
% Generate the glossary
\makeglossaries

\input{header}                            %loads all packages, definitions and settings, except bibliography (otherwise vim-latex doesn't recognise for completion)
% Some definitions
\definecolor{highlightyellow}{RGB}{250,237,39}
\urldef{\gitpluginurl}\url{https://github.com/TKone7/clightning-plugins/tree/3b47ab992413d7bf9747be1320654b3478c60d37/dumpgraph}

%%---Bibliography------------------------------------------------------------------------
%% \usepackage[style=ieee,urldate=comp,backend=biber]{biblatex}
%% \addbibresource{literature/bibliography.bib}

\usepackage[natbib=true, citestyle=apa, bibstyle=apa]{biblatex}
\bibliography{literature/bibliography.bib}


\title{Effectivenes simulation of a rebalancing algorithm for the Lightning Network under partial participation}                          %Project Title
\author{Bachelor Thesis}                %Document Type => Technical Report, ...
\date{August 1, 2020}                   %Place and Date

\begin{document}
%%---TITLEPAGE---------------------------------------------------------------------------
\selectlanguage{english}                %ngerman or english
\maketitle

\vspace*{-1cm}                            %compensates the space after the date line.
\vfill
{
\renewcommand\arraystretch{2}
\begin{center}
\begin{tabular}{>{\bf}p{4cm} l}
Organization                  &    FHNW, School of Business, Basel\\
Study program                 &    Business Information Technology\\
Author                        &    Tobias Koller\\
Supervisor                    &    Prof. Dr. Kaspar Riesen\\
Project sponsor               &    Prof. Dr. Thomas Hanne\\
Expert                        &    René Pickhardt
\end{tabular}
\end{center}
}
\clearpage

%% -- ABSTRACT
\thispagestyle{empty}
\begin{abstract}
  Here follows my abstract
  \lipsum{1-2}

  \vspace{2ex}
  \textbf{Keywords: Lightning, Bitcoin, path finding}
\end{abstract}
\vfill

%%---TABLE OF CONTENTS-------------------------------------------------------------------
\pagenumbering{Roman}		
\tableofcontents
\clearpage

%%---DECLARATION OF HONOR
\addcontentsline{toc}{section}{Declaration of honor}
\vfill\noindent
\begin{center}
 \section*{DECLARATION OF HONOR}
\end{center}

I the undersigned declare that all material presented in this paper is my own work or fully and specifically acknowledged wherever adapted from other sources. I understand that if at any time it is shown that I have significantly misrepresented material presented here, any degree or credits awarded to me on the basis of that material may be revoked. I declare that all statements and information contained herein are true, correct and accurate to the best of my knowledge and belief. This  paper or part of it have not been published to date. It has thus not been made available to other interested parties or examination boards.  

\vspace*{4em}\noindent
\hfill%
\begin{tabular}[t]{c}
  \rule{10em}{0.4pt}\\Tobias Koller 
\end{tabular}%
\hfill%
\begin{tabular}[t]{c}
  \rule{10em}{0.4pt}\\ Place / Date
\end{tabular}%
\hfill\strut
\clearpage

%%---FOREWORD
\section*{Foreword}
\addcontentsline{toc}{section}{Foreword}
\todo[inline]{Some background}
\clearpage

%%---GLOSSARY
\clearpage


\pagenumbering{arabic}
\section{Introduction} 
This section gives a brief introduction and overview of the Bitcoin and Lightning technology. It covers the history of digital cash, the advent of Bitcoin and explains the need for an off-chain scaling solution. 

\subsection{Bitcoin: Peer to Peer Electronic Cash}\label{subsec:peertopeer}
Bitcoin is a peer-to-peer electronic cash system first introduced in a white paper by the individual or group behind the pseudonym Satoshi Nakamoto \citep{nakamoto_bitcoin_2008}. This paper lines out the fundamental principles of the Bitcoin block chain \todo{glossary block chain} that achieves digital transfer of value without a central third party. The next paragraph expands on the pre-bitcoin developments on electronic cash that eventually lead to the rise of Bitcoin. Additionally, we explain why there is a need for additional layer protocols.

\subsubsection{History of digital cash}
Before the digital age cash was the dominant form of payment. A bank note or a coin embodies the respective face value to the bearer of it. Economical transactions can be made by simply exchanging this physical token by which the transaction was immediately settled. However, with the advent of e-commerce this simple and transparent mechanism was no longer possible. New institutions formed to fulfill the need of online transactions. Credit card companies and payment processors filled the gap of trust needed between the sender and the receiver of a transaction over the internet. This architecture came with significant drawbacks. Suddenly, the interacting parties are dependent on third parties which are collecting additional fees. Use of such systems require identification and since the intermediary can track all transactions, this reduces the user's privacy \citep{narayanan_bitcoin_2016}.

Bitcoin is by no means the first system introduced to allow for a digital cash system. Already in in 1983 \citeauthor{chaum_blind_1983} worked on new cryptographic primitives that should make electronic banking services more private and offer improved auditability \citep{chaum_blind_1983}. Although his technology still relied on a central ``bank'' server which issues electronic bills, blinded signatures allowed to anonymously transfer them. In 1989 the company \textbf{DigiCash} was found by Chaum to commercialise the idea and a few banks did later implement it. Technological complexity, patents on the invention and the incapability of handling  user-to-user transactions prevented it from becoming a success \cite{narayanan_bitcoin_2016}. 

An important problem in the evolution of digital cash has been the so called \textbf{\gls{doublespend}}. Digital information has the property of being easily duplicated. This poses a problem to digital cash as this behaviour is generally unwanted. How can a receiver of digital cash be certain that the cash has not been spent to someone else before, thus eliminating its value? Satoshi Nakamoto introduced the concept of a global distributed ledger, a data structure that is append only and where any change must be disseminated to all participants. In order to keep the history of the ledger immutable Satoshi utilizes the idea of a time stamping server first proposed by \textcite{haber_how_1991} in 1991. It works by calculating the hash of a piece of data and publishing it to all the participants. This serves as a proof that the data existed at this given time since otherwise the hash could not have been calculated. The next piece of data to be published also contains the previous hash, effectively linking them and forming a chain. If someone would now want to change the underlying data this would change its hash and since it is included in the next element in the chain also this hash would need to be changed up until the most recent element. 
\todo[inline]{explain hash and add to glossary}

Maintaining a global state of transactions in a constantly changing network of participants which can not be trusted is challenging. A single user could spin up hundreds of nodes to overcome the conses of the network. How can a consensus be formed without a central authority? A solution to a similar problem was proposed by \textcite{back_hashcash_2002} in 2002. To prevent e-mail spamming he introduced a mechanism that requires the sender to solve a puzzle that is computational heavy. This so called ``proof of work'' is requested by the receiver of the e-mail to trust that it is no spam. Since this computation can easily be done for one e-mail it becomes a big burden to do for thousand of e-mails therefore avoiding spammers. The puzzle simply involves finding a value whose hash starts with a certain amount of zero bits. Since the result of a hash function can not be predicted only brute force can be applied to find such a value. By selecting the number of leading zero bits one can change the difficulty of the puzzle. Each additional zero leads to the difficulty to be doubled. In order to add transactions to the Bitcoin ledger a participant constructs a block consisting of transactions, computes the proof of work and publishes it to the network. Only if all transactions are valid and the work done has been verified network participants append the transactions to their local copy of the ledger and further broadcast the block.  
\todo[inline]{add pow to glossary}

Combining proof of work with the chaining of hashes introduced in the last paragraph results in a strong security model. An attacker who wants to change the history of the ledger would need to recompute the proof of work of the changed and all subsequent blocks as they are linked by their hashes. Therefore, every new block makes it increasingly more difficult to change a transaction in the ledger. Number of blocks on top of a transaction in question is hence be referred to as \textbf{confirmations}.  

\subsubsection{Scaling solutions}
One of Bitcoin's value propositions is being decentralised. At the same time every transaction ever made must be distributed and stored among all network peers. It becomes obvious that some trade-off has to be made to maintain those two properties: scalability. This is often referred to as the scalability trilemma \todo{trillema in glossary} which states that in distributed systems the three objectives \textbf{security}, \textbf{decentralisation} and \textbf{scalability} can not be achieved in full extent at the same time. While two can often be achieved, there are certain trade-offs to be made in the third domain. This section is explaining why this is true for Bitcoin and what main categories of solution exist.

While decentralisation can be described on many levels we focus here on the decentralisation of validating nodes. Those are network participants that verify the blocks published by miners. Decentralisation would be best achieved if  every user of Bitcoin would run its own fully validating node \todo{add full node to glossary}to receive information about the ledger independently. On the other hand the network would be centralised when only few nodes would validate and users would need to trust those to tell the truth about the ledger state. To keep decentralisation high it is crucial to keep the hardware and network requirements as low as possible. The Bitcoin protocol restricts the amount of data to be processed to one block of 1 megabyte per 10 minutes. A full node in the network must be able to download at least 1 MB / 10 minutes in order to keep up with the tip of the chain. Lower bandwidth would cause it to get left behind without every being able to catch up. Additionally, the full node must keep the full ledger on storage. This yields to approximately 286 GB \cite{noauthor_blocks-size_nodate} at time of writing, increasing linearly in the future. This upper limit block size results in a throughput of approximately 7 transactions per second (tps) \cite{poon_bitcoin_2016}. Clearly by several orders of magnitude smaller than what it would require to become a world wide payments network. 

Bitcoin, by design, promotes security and decentralisation while sacrificing scalability. However, to be usable by everyone the scalability issue needs to be addressed. As Bitcoin is not owned by anyone there is no one party to decide on the future design decisions. This lead to a scaling debate with two ideological camps on how to progress. Scaling on-chain or scaling off-chain.

Scaling on-chain means lifting the 1 megabyte block limit, allowing for a higher transaction throughput. While this seems the most straight forward solution it can not be achieved without trade-off. As previously discussed decentralisation can only be maintained by keeping the hardware and network requirements low. Removing this restriction to allow worldwide usage would mean that nodes soon need to process hundreds of megabytes or even gigabytes per second, effectively reducing the number of nodes that can still keep up, leading to a more centralised network. 

An off-chain scaling solution describes any system that acts outside of the Bitcoin protocol but is linked to it, in a way that leverages the number of economical transactions that can be performed per single on-chain transaction. These solutions build a second layer \todo{glossary second layer} of abstraction. While still using functionality of the base layer \todo{glossary base layer} they can reduce their dependency and make their own design decisions and trade-offs based on the scalability trilemma. The Lightning Network is only one possible off-chain solution and is described in the next section in more depth. 

\subsection{Lightning technology}
The Lightning Network is a network protocol that utilizes Bitcoin as its underlying trust system. It can, therefore, be described as a ``second layer'' protocol building upon the Bitcoin ``base layer''. Bitcoin does not scale on the base layer since it was designed with security and decentralisation in mind. Off-chain solutions like Lightning are developed to facilitate more transactions on a different layer without compromising the properties of the base layer \citep{poon_bitcoin_2016}.

\subsubsection{Payment channels}
The transaction bottleneck in Bitcoin is imposed since every network participant needs to be updated about every transaction. This is required to ensure the integrity of the system and not because the transactions are of interest to the nodes. In fact they can learn very little about the parties involved in a transaction as pseudonymous public keys are used as identifiers. \citeauthor{poon_bitcoin_2016} mention in the Lightning Network Paper that as long as only two participants care about a recurring transaction there is no need to inform the entire network about it \citep{poon_bitcoin_2016}. They therefore propose that those two participants do not sent the transaction to the network but instead hold on to it and agree on their balances bilaterally. \textquote[{\cite{poon_bitcoin_2016}}, p. 4]{Micropayment channels create a relationship between two parties to perpetually update balances, deferring what is broadcast to the block chain in a single transaction netting out the total balance between those two parties.}

Opening such a payment channel requires the two parties to create an on-chain Bitcoin transaction which spends an amount of bitcoin to a 2-of-2 multisignature contract. Only both parties collaboratively can spend it from there. At the same time they create a refund transaction that spends from the multisignature contract and distributes the current balance state. However, they could broadcast this transaction instead they can also decide to hold on to it and update it at a later stage. Holding the signed Bitcoin transaction ensures that they could at any time get their balance back on-chain. Every time they wish to transact with each other they just sign a new refund transaction which distributes the updated channel balance.

\textit{Example:} Assume Alice and Bob open a payment channel and both send 0.5 BTC to a 2-of-2 multisignature contract. This channel has a total capacity of $0.5 + 0.5 = 1$ BTC. At the same time they also create a transaction that pays them back their initial balance of 0.5 BTC each. This transaction is not sent to the block chain but kept private by the two parties. If Alice wants to send Bob 0.2 BTC they update this transaction spending the initial 1 BTC to be distributed as follows: 0.3 BTC to Alice; 0.7 BTC to Bob. This payment was only agreed upon Alice and Bob, no one else needed to be notified. Unlimited future transactions like this can take place as long as the sender still has some balance. At any point in time Alice or Bob can decide to broadcast the latest transaction, distributing the agreed balance and effectively closing the payment channel. As depicted in figure~\ref{fig:ChannelCycle} there can be many modifications to that balance.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{channel_lifecycle.pdf}
\caption{Life cycle of payment channel.}
\label{fig:ChannelCycle}
\end{figure}

Whenever the parties decide to end there collaboration they can close the channel by broadcasting a closing transaction to the block chain which pays out each party its respective balance. While beneficial, collaborative channel closure is not required, each party can close the channel at any given time by broadcasting the latest transaction agreed upon. 

Participants in such channels are referred to as Lightning nodes, a computer system that runs an implementation of the Lightning Network protocol. Those nodes are not to be confused with Bitcoin nodes. However, since most Lightning nodes need direct access to the Bitcoin block chain most Lightning nodes are Bitcoin nodes at the same time.

\subsubsection{Using other channels for payments}
Since a payment channel is a biparty relationship an update of channel balance can only ever represent a transaction between those parties. Instead of opening a channel to each participant a node wants to transact with there is the opportunity to route payments through multiple channels.

Often economical transactions \todo{glossary econ. tx} to a specific recipient are made only once. It would therefore, defeat the purpose of Lightning to open a channel for this unique payment because both opening and closing of a channel takes each one transaction on the base block chain. Using Lightning would not use the load on-chain but rather increase it by a factor of two. This demonstrates that a payment channel should only be opened if the cost of doing so can be amortised over many transactions. This is either the case if the channel parties are expected to repeatedly transact with each other or if they can facilitate transactions between other nodes in the network through routing. 

Handling payments off-chain so far only worked between two parties that update Bitcoin transactions off-chain with the security of claiming their balance at any time on-chain. How can payments through multiple channels be accomplished without introducing trust into the system? If Alice wants to pay Carol through Bob, how can she be ensured that Bob will not keep the money and refuse to pay Carol? The solution are so called \textbf{Hash Time Locked Contracts} or short ``HTLC'' \todo{define htlc in glossary}. 

First Alice asks the payee, Carol, to create and keep a secret \textbf{R} and only share the hash of it, $hash(R)$. Alice then uses this, so called \textit{preimage} \todo{glossary preimage}, to create a special HTLC transaction that promises Bob to receive the payment amount if he has knowledge of $R$. Bob also gets informed by Alice who is next in the path to find out this secret. Bob then himself creates an HTLC with the same preimage to Carol offering her the same amount upon disclosure of $R$. Carol is the payee in the transaction and has knowledge of $R$ so she could technically claim the funds on-chain. There is however an easier solution than this. After she releases $R$, Carol and Bob can simply agree to update their channel to reflect this payment. The same is done between Alice and Bob leading to the state where all channel balances are updated and the HTLCs is rendered useless. This mechanism is called ``time locked'' because the offer of payment to the knowing $R$ is only valid for a certain timespan. If $R$ does not get released until the defined expiry the HTLC turns invalid. Therefore, it is important that each successive HTLC has a lower timespan.

\subsubsection{Routing}\label{subsec:routing}
The previous chapter explained how a payment can utilize multiple channels to reach its destination without the introduction of trust between participants. This section describes how routing takes place and what trade-off needs to be made.

To ensure privacy of payments the routing protocol uses onion routing \todo{define onion routing in glossary}. The sender of the payment encrypts the information in multiple layers so that each hop only learns about the next hop in the path. Each intermediary node only knows where the payment comes from and where it goes next. Who is the payer and the payee remains secret. Only the last node in the path finds out that it is the actual receiver of a payment.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\linewidth]{htlc.pdf}
\caption{Onion routing preserves privacy over the chose path.}
\label{fig:onion}
\end{figure}

Figure~\ref{fig:onion} color codes the information which is only readable by the respective node with the same color. In each step the outermost layer is decrypted and the next hop gets revealed. The remaining encrypted data is passed on down the line. This ensures that each node only has a local view of the path knowing only about its predecessor and successor. Thus follows, the source of the payment needs to determine the complete path before sending a payment.

Sending a payment requires the sender to find a viable path to the recipient. This is called source routing \todo{glossary source routing} and necessitates some information about the channel graph. When a new channel opens the parties notify the network about the channel, its capacity and the fee policies. Each other network participants stores this information and builds up its local view of the network. When a node constructs a payment it can query a path with enough capacity along all its channels, though this is not enough to be certain that the payment can be routed. The payment in figure~\ref{fig:nopayment} of $0.5$ BTC can not be routed from Bob to Carol as Bob only owns $0.2$ BTC of the $1$ BTC channel between him and Carol. This information however is only known to Bob and Carol, not to Alice. Alice only sees the public information which tells her that the channel has 1 BTC capacity. Local channel balances are kept private for two reasons. Every payment over a channel makes its balances to move. Keeping all nodes updated about all channel balances would necessitate to update them about every transaction. This is exactly how Bitcoin on the base layer work and the reason it does not scale. Secondly, informing the Network about every transaction is very bad for privacy, as an observer could easily determine who pays to whom over what path.

Not knowing local balance distribution of channels makes it hard for source nodes to construct a reliable path. When a payment fails along the path a new route can be calculated and tried. This however is coupled with time delays that can cause a negative user experience.

\begin{figure}[H]
\centering
\includegraphics[width=1.0\linewidth]{nopayment.pdf}
\caption{Payment fails when channel balances cannot accommodate the required transfer.}
\label{fig:nopayment}
\end{figure}

%\newpage
\section{Problems in graph theory}
Graph theory is an old discipline which can be used to solve multifaceted problems in the real world. The following chapter contains an introduction to the basic principles and terminologies. It then defines different problems for which graph theory can be used to find solutions. More emphasis is given to the topics which are applicable to the Lightning Network.

\subsection{Formal definition}\label{subsec:formal}
The following paragraph defines the fundamentals of graph theory as described by \citet{rosen_discrete_2012}.
A graph $G=(V,E)$ consists of a set of vertices $V$ and edges $E$. An edge consists of two vertices which are called its endpoints. In an undirected graph the endpoints are unordered, whereas the pair of vertices in a directed graph are ordered. The edge $(u, v)$ of a directed graph starts at $u$ and ends in $v$. In a \textbf{simple directed} graph each directed edge can appear only once. When multiple edges go from one start vertex to the same end vertex the graph is named \textbf{directed multigraph}. An edge that connects a vertex to itself is called a loop. Assigning weights to edges allows for more complex representations mere connection and is useful if the real world representation of a connection has certain \textbf{cost} or \textbf{distance} that one might want to minimise (maximise). 

\todo[inline]{Go from general graph theory problems into more specific areas, 1 paragraph per topic}
\todo[inline]{Explain why finding a path in the lightning network can be so difficult}
\subsection{Overview of broad problems}
Per problem  one paragraph per

In \textbf{graph coloring problems} vertices can be thought of areas on a map. Areas that share a border are connected with an edge. The goal is to use as little colors as possible to color each area / vertex in such a way that adjacent areas have different colors. This minimum number is called the \textit{chromatic number} $\chi(G)$. 

Certain properties of graphs can only be proven if they are fulfilled in all their \textbf{subgraphs}. Hence, it is important to find those. A graph $H = (W, F)$ is a subgraph of $G = (V, E)$ when $W \subseteq V$ and $F \subseteq E$. A subgraph can be \textbf{induced} by $W \subseteq V$ which means the edge set $F$ contains only edges of $E$ for which both endpoints are contained in $W$. Similarly the union can be built of two graphs $G_1$ and $G_2$ where $G = G_1 \cup G_2$ and $V = V_1 \cup V_2$. 

Another area of graph theory aims to determine whether two graphs are \textbf{isomorphic}. This means \textquote[{\cite{rosen_discrete_2012}}, p. 668]{there is a one-to-one correspondence between their vertex sets that preserves edges.} Different algorithms are being developed that can determine isomorphism of two graphs, however with exponential worst-case time complexity. These algorithms mainly find application in chemistry and bioinformatics.  

Different \textbf{route problems} exist where the solution tries to find a path with certain properties within the graph. In the ``seven bridges of Königsberg'' the four sections of land are separated by a river and seven bridges are connecting them. The problem of passing every bridge exactly once and returning to the start can be formulated in terms of a graph with sections as vertices and bridges as edges. It is the question whether a graph has an Euler circuit or not. Many real-world applications exist where each edge needs to be visited once.

When edges have a weight assigned different problems can be modelled and optimised by finding a shortest path. A famous algorithm to find such a path is ``Dijkstra’s Algorithm''. Similarly, in the Traveling Salesperson Problem each vertex needs to be visited exactly one before returning to the starting point. Algorithms finding a path with low cost often use approximation since no algorithm with polynomial worst-case complexity exists. 

Different problems deal with the \textbf{flow} in a network. Such networks have a capacity assigned to each directed edge. Often the goal is to find the maximum flow between a source and a sink node such that all intermediary nodes have equal in and outflow \citep{even_network_1975}.

\subsection{Application in the Lightning Network}
The Lightning network can best be described by a \textbf{simple directed graph}. That is a graph with directed edges without loops and multiple directed edges. Since a payment channel between $u$ and $v$ allows payments to flow in both direction it can be modelled by use of two edges $(u, v)$ and $(v, u)$. In terms of network flow theory the capacity is the amount that can flow from $u$ to $v$ which in Lightning is defined as the local channel balance of $u$. Figure~\ref{fig:channel_graph} visualises a channel between Alice and Bob with 1 BTC capacity of which Alice holds 0.2 BTC and Bob holds 0.8 BTC.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{simple_channel.pdf}
\caption{Lightning channel represented as simple directed graph..}
\label{fig:channel_graph}
\end{figure}

\subsubsection{Fees}
So far the properties of a network graph could be mapped to a Lightning payment channel. There is another concept within lightning that need to be accounted for. When payment channels get used by other nodes than the two channel partners they can ask for fee to be paid. This can be compared to a bridge toll that needs to be paid by everyone crossing the bridge. It is a compensation for the capital that the channel owner has ``locked''. The fee consists of two parts, a fixed fee and a variable fee. While the fixed fee is the same for every payment, the variable increases linearly with the amount being transferred.

\subsubsection{Path finding problem}
As laid out in section~\ref{subsec:routing} the initiator of a payment needs to construct the path before sending the payment. Nodes trying to find such a path work with limited information. While they know what channels are available and what their capacities are, they do not know about the balances and therefore whether the nodes can forward their payment or not. Hence, it is likely that a payment attempt fails because a node had insufficient balance. The paying node needs to find another route and retry the payment until it succeeds. If the payment fails repeatedly it can cause delays that are bad for the user experience.

This problem gets amplified because in the current protocol channels are single funded. This means one party provides 100\% of the channel capacity. A collaborative approach to funding a channel might be possible in the future. As a consequence the funder of the channel owns initially 100\% of the channel balance and the other side 0\% which means the channel can only be used to route into \textbf{one direction}. A third party trying to route through this channel has a 50:50 chance that he or she can not even route a minimal amount of 1 satoshi \todo{define satoshi and other units of btc}. 

The Lightning path finding problem can best described by a \textbf{flow network} \todo{glossary flow network}. The goal of a node constructing a payment is to find a path that has enough capacity along its channels to route to the destination. Rules from flow networks apply according to which each node, except source and sink node, must have equal amounts flowing in as are flowing out. 

In the next sections terminology native to the Lightning protocol is used. I refer to the directed graph as the \textbf{network}. Vertices are called \textbf{nodes} and a pair of opposite directed edges are a \textbf{channel}. The \textbf{capacity} defines the \textbf{total amount} of a channel which is distributed between the two node's balance, as opposed to the amount which can flow in flow networks. This flow is determined by the node's \textbf{balance}. The terms \textbf{route} or \textbf{path} are used interchangeably and are defined by a set of channels that can be traversed. \textbf{Fees} is the general term that includes both \textbf{fixed fees} and \textbf{variable fees}. Fee policies are set by each node individually for every channel. This means a channel can charge different fees in either way as both nodes set the fee policy for their balance. \textbf{Rebalancing} is the activity of routing a payment in a circle back to the initiating node and is used to reallocate balances within the set of channels a node controls.   

\subsection{Previous work}
Pickhardt's and Nowostawski's publication ``Imbalance measure and proactive channel rebalancing algorithm for the Lightning Network'' \citep{pickhardt_imbalance_2019} serves as a base to formulate the question for this thesis. In their work, they present a solution for the pathfinding problem in a privacy-aware payment channel network. The proposed solution includes a rebalancing protocol which the nodes of the network should follow to achieve a higher balancedness (for itself but also the entire network). It consists of instructions to proactively rebalance their channels within their friend of a friend's network, redistributing the relative funds owned in a channel but leaving total funds owned unchanged.

Rebalancing is an activity where one node engages in a circular payment that pays itself. This is only possible when the node has at least two channels with different peers. The payment gets routed \textbf{out} through one channel and is \textbf{received back} over another. On the way, it can use one or more hops to find back to the sender node. This procedure enables a node to change the balances of the individual channels while the total node balance stays the same. In practice, there would be a fee collected by the intermediate nodes whose channels are used. In the proposed rebalancing protocol nodes would forego the fee and only participate in the rebalancing attempt if their balancedness improves as well. The rebalancing algorithm is described in more detail in the section \todo{include ref to experiment}. 


\subsection{Problem statement}
These payment channel networks are decentralized by nature and protocol changes can not be forced upon the node operators. Therefore, the question arises on how effective this protocol change will be assuming only partial participation of nodes. What are the effects of different levels of participation on the imbalance measure \footnote{Defined as the inequality of the distribution of a nodes channel balance coefficients} of the network during repeated rebalancing cycles? What is the effect of different levels of participation on the network's ability to route payments between random nodes? 

The next part of the paper defines the rebalancing algorithm proposed in a protocol change. Then an experiment is constructed which mimics the real Lightning Network with all its participants and payment channels. I formally define multiple performance measurements which are later used to measure the improvement of the network's ability to route payments. Different scenarios are then simulated under different levels of participation also testing different ways to select the participating nodes.

\newpage
\section{Experiment}\label{sec:method}
\subsection{Data collection \& Preprocessing}
Data for the simulation was first collected from a Lightning node, the required features were extracted and multiple cleaning and preprocessing steps were performed. 

\subsubsection{Retrieve data from Lightning node}
In order to run a simulation that resembles the real network closely data from a productive Lightning node are best fitted to construct the model. Lightning is an open network which means it is easy to setup a node and download all the channel information. One implementationi of a Lightning Network node is C-Lightning and they offer a flexible interface to write own plugins which can interact with the node over Remote Procedure Calls. I wrote a plugin \footnote{\gitpluginurl} in Python that writes all known channels to a json file. The JSON code snippet~\ref{code:rawchannel} shows what is returned by C-Lightning as result. The plugin extracts the  highlighted parts and writes them into a file.

\begin{listing}[H]
  \inputminted[
    frame=single,
    framesep=3mm,
    linenos=true,
    xleftmargin=21pt,
    tabsize=4,
    breaklines=true,
    breakanywhere=true,
    highlightlines={4-6,8,14-15},
    highlightcolor=highlightyellow,
  ]{js}{code/raw.json}
  \caption{Raw channels provided by C-Lightning.}
  \label{code:rawchannel}
\end{listing}



\begin{listing}[H]
  \inputminted[
    frame=single,
    framesep=3mm,
    linenos=true,
    xleftmargin=21pt,
    tabsize=4,
    breaklines=true,
    breakanywhere=true
  ]{js}{code/channels.json}
  \caption{Sample channels file with only one channel.}
\end{listing}

\subsection{Simulating Lightning Network}
\todo[inline]{Define everything in the network.py class that mimics the ln network (balances, capacities, fees, routing)}

\subsection{Routing protocol}
\todo[inline]{Describe how the proposed protocol change is impolemented in the \textbf{Network} class. }
\todo[inline]{show illustrations with a dummy network}
\todo[inline]{ask Rene to his dummy network}

\subsection{Performance Measures}
\todo[inline]{list the two existing and the third new performance measurement}
\subsubsection{Success rate on shortest path}
bla
\subsubsection{Payment size on shortest path}
dl
\subsubsection{Ability to route different payment sizes}
bla
\subsection{Methodology}
\todo[inline]{explain how to get the network information for a running node. quickly show how I extracted the data from the full node. Explain the structure of the python class \textbf{Network}}. And some more \textbf{bold text}.

To model the network, public information from the Lightning Network is used. From a Lightning node, all the channel and node information can be extracted.

For all further manipulations and calculations, the programming language Python will be used. This includes writing code that facilitates: 
\begin{itemize}
  \item The selection of nodes, participating in the protocol change.
  \item Implement the proposed algorithm \cite[p.~3]{pickhardt_imbalance_2019}.
  \item Performing rebalancing in the network.
  \item Storing different network states for different scenarios.
  \item Calculate different performance measures.
  \item Aggregate data.
  \item Plot graphs to visualize the results.
\end{itemize}


\section{Results}
Show a lot of charts :-)
\newpage
\newgeometry{left=1cm,right=0.1cm}
\begin{figure}
\begin{tabular}{ccc}
  \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_02_40.pdf} &   \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_10_40.pdf} & \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_15_40.pdf}  \\
  (a) Init: 2 Spread: 40  & (b) Init: 10 Spread: 40 & (c) Init: 15 Spread: 40  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_02_50.pdf} &   \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_10_50.pdf} & \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_15_50.pdf}  \\
  (d) Init: 2 Spread: 50  & (e) Init: 10 Spread: 50 & (f) Init: 15 Spread: 50  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_02_60.pdf} &   \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_10_60.pdf} & \includegraphics[width=60mm]{3a65a961_successrate_vs_participation_netw_spread_15_60.pdf}  \\
  (g) Init: 2 Spread: 60  & (h) Init: 10 Spread: 60 & (i) Init: 15 Spread: 60  \\[6pt]
\end{tabular}
\caption{Success Rate}
\end{figure}

\newpage 
\begin{figure}
\begin{tabular}{ccc}
  \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_02_40.pdf} &   \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_10_40.pdf} & \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_15_40.pdf}  \\
  (a) Init: 2 Spread: 40  & (b) Init: 10 Spread: 40 & (c) Init: 15 Spread: 40  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_02_50.pdf} &   \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_10_50.pdf} & \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_15_50.pdf}  \\
  (d) Init: 2 Spread: 50  & (e) Init: 10 Spread: 50 & (f) Init: 15 Spread: 50  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_02_60.pdf} &   \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_10_60.pdf} & \includegraphics[width=60mm]{3a65a961_median_paymnet_size_vs_participation_netw_spread_15_60.pdf}  \\
  (g) Init: 2 Spread: 60  & (h) Init: 10 Spread: 60 & (i) Init: 15 Spread: 60  \\[6pt]
\end{tabular}
\caption{Median possible payment size}
\end{figure}

\newpage 
\begin{figure}
\begin{tabular}{ccc}
  \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_02_40.pdf} &   \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_10_40.pdf} & \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_15_40.pdf}  \\
  (a) Init: 2 Spread: 40  & (b) Init: 10 Spread: 40 & (c) Init: 15 Spread: 40  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_02_50.pdf} &   \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_10_50.pdf} & \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_15_50.pdf}  \\
  (d) Init: 2 Spread: 50  & (e) Init: 10 Spread: 50 & (f) Init: 15 Spread: 50  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_02_60.pdf} &   \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_10_60.pdf} & \includegraphics[width=60mm]{3a65a961_median_paymnets_vs_participation_netw_spread_15_60.pdf}  \\
  (g) Init: 2 Spread: 60  & (h) Init: 10 Spread: 60 & (i) Init: 15 Spread: 60  \\[6pt]
\end{tabular}
\caption{Different payment sizes}
\end{figure}

\newpage 
\begin{figure}
\begin{tabular}{ccc}
  \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_02_40.pdf} &   \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_10_40.pdf} & \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_15_40.pdf}  \\
  (a) Init: 2 Spread: 40  & (b) Init: 10 Spread: 40 & (c) Init: 15 Spread: 40  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_02_50.pdf} &   \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_10_50.pdf} & \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_15_50.pdf}  \\
  (d) Init: 2 Spread: 50  & (e) Init: 10 Spread: 50 & (f) Init: 15 Spread: 50  \\[6pt]
  \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_02_60.pdf} &   \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_10_60.pdf} & \includegraphics[width=60mm]{3a65a961_gini_vs_participation_netw_spread_15_60.pdf}  \\
  (g) Init: 2 Spread: 60  & (h) Init: 10 Spread: 60 & (i) Init: 15 Spread: 60  \\[6pt]
%\multicolumn{2}{c}{\includegraphics[width=60mm]{3a65a961_gini_vs_rebalops_netw_spread_02_40.pdf} }\\
%\multicolumn{2}{c}{(e) fifth}
\end{tabular}
\caption{Different payment sizes}
\end{figure}
\restoregeometry

\section{Conclusion \& Outlook}
%% Dummy text

%%---BIBLIOGRAPHY------------------------------------------------------------------------
\newpage
{\sloppypar
\printbibliography[heading=bibintoc]
\label{sec:lit}
}


%Print the glossary
\newpage
\newglossaryentry{doublespend}{name={double spend problem}, description={Problem in digital cash systems that a digital token can be duplicated at will and used as payment to multiple receivers at the same time making it difficult to detect the fraud.}}
\section*{Glossary}
\printglossaries

\appendix
\section{Some appendix}
maybe\ldots

%%---TODO-OVERVIEW-------------------
\ifdraft{%Do this only if mode=draft
\newpage
\listoftodos[\section{Todo-Notes}]
\clearpage
}
{%Do this only if mode=final
}

\end{document}

